{% extends 'base-articles.html' %}


{% block article_template_image %}
    <img 
        src="{{ url_for('static', filename='img/' + topic_object.image_name) }}"  
        alt="{{ topic_object.title }} - template image"
        class="img-fluid"
    >
{% endblock %}


{% block article_title %}
    {{ topic_object.title }}
{% endblock %}


{% block article_title_description %}
    {{ topic_object.description }}
{% endblock %}


{% block article_pills %}
    <a target="_blank" href="https://docs.obspy.org/tutorial/index.html"><span class="badge rounded-pill">Obspy</span></a>
    <a target="_blank" href="https://docs.obspy.org/packages/autogen/obspy.core.stream.Stream.html"><span class="badge rounded-pill">Stream</span></a>
    <a target="_blank" href="https://docs.obspy.org/packages/autogen/obspy.core.trace.Trace.html"><span class="badge rounded-pill">Trace</span></a>
    <a target="_blank" href="https://docs.obspy.org/packages/autogen/obspy.core.stream.read.html"><span class="badge rounded-pill">read</span></a>
    <a target="_blank" href="https://docs.obspy.org/packages/autogen/obspy.core.trace.Stats.html"><span class="badge rounded-pill">stats</span></a>
{% endblock %}


{% block article_list_items %}
    <li><a href="#item-1">Basic structure</a></li>
    <li><a href="#item-2">Obspy Date and Time Manipulation</a></li>
    <li><a href="#item-3">Attributes and Methods</a></li>
    <li><a href="#item-4">Generating Trace and Stream objects from data</a></li>
{% endblock %}

{% block article_main_content %}
 
    <div id="item-1">
        <h1>Basic structure</h1>
        <p>
            The main structure of the Obspy library consists of the <code>Trace</code> and the <code>Stream</code> objects. The <code>Trace</code> represents
            a single time series record of seismic data recorded at a single station or sensor. It's essentially a single waveform with associated metadata 
            (e.g., station code, sampling frequency, starting time of the recording etc.). 
            The <code>Stream</code> object is a container of one or more <code>Trace</code> objects. Typically, a <code>Stream</code> object, contains three recordings or traces: two with horizontal 
            components (e.g., North-South and East-West) and one with a vertical component and offers several attributes that provide information about the respective recording. 
        </p>
        <div class="figure-container">
            <figure>
                <img src="/static/img/obspy-structure.png" alt="mseed record ASCII file">
                <figcaption>The structure of the obspy library. A Stream consists of one or more Trace objects which have different methods (.taper(), .filter(), etc.) and attributes (.data, .stats, etc.)</figcaption>
            </figure>
        </div>
        <p>
            For instance, the <code>.data</code> attribute provides the 
            time series data samples and the <code>.stats</code> returns the seismic parameters of the recordings (sampling frequency, number of sample points, etc.). In addition, it provides several methods or functions to 
            manipulate the record. Such methods are the <code>filter()</code> function that filters the recordings between a specific frequency range and the <code>trim()</code> function
            that trims the time series between a specific starting and ending time.
        </p>
        <p>
            Obspy supports several file <a target="_blank" href="https://docs.obspy.org/packages/autogen/obspy.core.stream.read.html">formats</a> to read data. 
            One of the most used seimic file formats is the MiniSEED format. It is a binary file used to store time series data in a compact and 
            efficient format that includes information about the station, location, timing, and the actual waveform data. MiniSEED files are widely
            used in seismology and are the standard format for sharing and archiving seismic data.
        </p>
        <p>
            Before we continue, start by initializing the functions that we will use throughout the rest of the tutorial:
        </p>
        <script src="https://gist.github.com/imarag/71ebe8e74a737bdaec527ed955bdf4b7.js"></script>
    </div>
    <div id="item-2">
        <h1>Obspy Date and Time Manipulation</h1>
        <p>
            Obspy offers extensive support for date and time manipulation. It includes the <code>UTCDateTime</code> object to represent date and time. 
            For instance the start date and the end date of a recording, which are saved as <code>starttime</code> and <code>endtime</code> in the metadata information
            of a <code>Trace</code> object (the <code>.stats</code> attribute), are both a <code>UTCDateTime</code> data type.
        </p>
        <p>
            One way to create a <code>UTCDateTime</code> object is by using a Pyton string:
        </p>
        <script src="https://gist.github.com/imarag/c44b83682d43a63c8a3fdef9acd59301.js"></script>
        <p>
            You can perform addition, subtraction and extract multiple attributes from this object using the dot notation:
        </p>
        <script src="https://gist.github.com/imarag/1c7cc6560801d1997a3778d43a6afe3b.js"></script>
        
        <p>Last but not least, one can subtract <code>UTCDateTime</code> objects and get the difference of them in seconds:</p>
        <script src="https://gist.github.com/imarag/d02d9c3c8c936bea6292c4112873311b.js"></script>
        <p>
            The <code>starttime</code> and <code>endtime</code> keys in the header information of the recordings need to be in a <code>UTCDateTime</code> data type.  
            Therefore, if you intend to modify these keys within 
            the <code>trace.stats</code> dictionary-like header, convert your datetime string into the 
            <code>UTCDateTime</code> format.
        </p>
    </div>
    <div id="item-3">
        <h1>Attributes and Methods</h1>
        <p>
            Within ObsPy, you'll find an array of attributes and methods 
            associated with the <code>Trace</code> class for accessing 
            recording information, seismic file handling, and applying 
            waveform processing techniques. To begin with, utilize the Obspy
            <code>read()</code> function to read a file of a recording took 
            place on <code>04 April, 2014</code> 
            at <code>20:08:20</code> and recorded by <i>CH03</i> station:
        </p>
        <script src="https://gist.github.com/imarag/cef71d4af3fa102e54e6fe888ff774a6.js"></script>

        <p>
            The file is a MiniSEED file that contains 3 traces or records 
            each with a different component (E, N, Z). We can see the start 
            and the end time of the record, the sampling frequency in Hz 
            and the total samples. Let's get this information for the first 
            trace of the <code>Stream</code> object:
        </p>
        <script src="https://gist.github.com/imarag/13ce0156258101d85cfacc4930d42e04.js"></script>
        <p>
            We can observe multiple key-value pairs that contain the seismic parameters, such as the station code or name which is <i>CH03</i>, the component of the record which is East-West (E) and the the sampling frequency or sampling rate 
            of 100 Hz. Several other parameters are also apparent like the starting and the ending date of the record (starttime, endtime), the sample distance in seconds (dt), the total number of sample
            points (npts) and more. The output is a <code>obspy.core.trace.Stats</code> object which is a <code>dict-like</code> object that you can get and set the values. 
        </p>
        <p>
            In order to check the recordings visually, get the sample data and the time information using the <code>.data</code> and the <code>.times()</code> methods respectively.
        </p>
        <script src="https://gist.github.com/imarag/cfb72283ff0b9cc284c56f141a55a850.js"></script>
        <div class="figure-container">
            <figure>
                <img src="/static/img/ch03_mseed_plot.png" alt="mseed plot">
                <figcaption>Recordings of the MiniSEED file plotted using the matplotlib library</figcaption>
            </figure>
        </div>
        <p>
            We could achieve a similar result by just using the <code>st.plot()</code> method of the <code>Stream</code> object (st):
        </p>
        <div class="figure-container">
            <figure>
                <img src="/static/img/ch03_mseed_plot_method.png" alt="mseed plot">
                <figcaption>Recordings of the MiniSEED file plotted using the <code>.plot()</code> method of the <code>stream</code> object</figcaption>
            </figure>
        </div>
        <p>
            This method can get some parameters to control the visualization of the plots such as the color of the waveforms, the size of the plot, the rotation and size of the 
            x axis labels and more. Check all these parameters of the <a target="_blank" href="https://docs.obspy.org/packages/autogen/obspy.core.stream.Stream.plot.html">obspy.core.stream.Stream.plot</a> command.
        </p>
        <p>
            At this point, for the sake of the tutorial, let's assume that we need to calculate the Fourier spectra within a specific window of the signal in the waveforms. To accomplish this, there are several 
            preprocessing steps that need to be applied:
        </p>
        <ol>
            <li>Apply a bandpass filter from 1 to 5 Hz to remove the noise</li>
            <li>Select the arrivals of the P and S waves</li>
            <li>Define a window of 10 seconds to calculate the Fourier Spectra</li>
            <li>Trim the recordings inside that 10-second window</li>
            <li>Taper the waveforms so that they start and end with zero acceleration</li>
        </ol>
        <p>
            Start by applying a bandpass filter to the records from 1 to 5 Hz to remove the surrounding noise and facilitate the arrival selection. 
            Utilize the Obspy <code>filter()</code> function:
        </p>
        <script src="https://gist.github.com/imarag/d54cb68d57ebf3759dbc963474a48a6c.js"></script>
        <div class="figure-container">
            <figure>
                <img src="/static/img/obspy-stream-filtered.png" alt="mseed plot">
                <figcaption>Recordings after applying a bandpass filter of 1-5 Hz</figcaption>
            </figure>
        </div>
        <p>
            It's clear from the filtered waveforms, that the P wave arrivals occurs roughly at <code>20:08:33</code> and the S wave arrivals at <code>20:08:58</code>. 
            To plot the P-wave and S-wave arrivals on the waveforms, you 
            can use Matplotlib to mark these time points with vertical 
            lines. Here's an example of how you can do it in Python:
        </p>
        <script src="https://gist.github.com/imarag/20e1b4548a1b69fe4e5f11c295361c45.js"></script>
        <div class="figure-container">
            <figure>
                <img src="/static/img/arrivals.png" alt="mseed plot">
                <figcaption>Arrivals of the P (red dashed line) and the S (black dashed line) waves</figcaption>
            </figure>
        </div>
        <p>
            At this stage we define two windows to calculate the Fourier Spectra, one for the signal part of the waveform and one for the noise part.
            Both windows will share the same duration or length of 10 seconds. The first window 
            will start from the S wave arrival and the second one will begin 10 seconds before the P wave arrival. Let's visualize these windows: 
        </p>
        <script src="https://gist.github.com/imarag/fb383cf8879d821871f1438d920a0650.js"></script>
        <div class="figure-container">
            <figure>
                <img src="/static/img/windows.png" alt="mseed plot">
                <figcaption>Create two windows to calculate the Fourier Spectra, one at the signal part of the waveform and the other at the noise part. Both will have a duration of 10 seconds. The first starts at the S wave arrival and the second 10 seconds before the P arrival.</figcaption>
            </figure>
        </div>
        <p>
            To continue, trim the waveforms at the two windows using the Obspy <code>trim()</code> function. Here's how you can do it in Python:
        </p>
        <script src="https://gist.github.com/imarag/e250f716129c581c748d408a686d55fc.js"></script>
        <div class="figure-container">
            <figure>
                <img src="/static/img/trimmed.png" alt="mseed plot">
                <figcaption>Trimmed waveforms at the noise and the signal windows for all the components</figcaption>
            </figure>
        </div>
        <p>
            Lastly, taper the waveforms, in order to smooth the left and the right side of the waveforms, using the obspy <code>taper()</code> function:
        </p>
        <script src="https://gist.github.com/imarag/dd697ea2048b6f6b930b1f3f2aa5aa4b.js"></script>
        <div class="figure-container">
            <figure>
                <img src="/static/img/taper.png" alt="mseed plot">
                <figcaption>Trimmed (blue) and tappered (orange) waveforms at the noise and the signal window for all the components</figcaption>
            </figure>
        </div>
        <p>
            Finally we can calculate the Fourier Spectra at the noise and the signal window on the waveforms. 
            To save the final tappered and/or trimmed <code>Stream</code> objects, utilize the Obspy <code>write()</code> function to write the seismic data from a <code>Stream</code> object to a file in 
            various supported formats. It allows you to save the seismic data, including metadata, to a file for further analysis or sharing with others.
        </p>
        <script src="https://gist.github.com/imarag/3ff579872ada6cee57f0bb47936ac965.js"></script>
        <p>
            In this section we have explored several attributes and methods of the Obspy <code>Trace</code> object,
            including the <code>read</code> and <code>write</code> methods to upload and save seismic files, the <code>.data</code> 
            and <code>.stats</code> attributes to extract information about the recordings, 
            the <code>trim()</code>, <code>taper()</code> and <code>filter()</code> functions to manipulate the traces and the 
            <code>plot()</code> function to plot the recordings. Obspy offers
            a wide range of additional attributes and methods for working with seismic data at the 
            <a target="_blank" href="https://docs.obspy.org/packages/autogen/obspy.core.trace.Trace.html">Trace</a> object
            documentation.
        </p>
    </div>
    <div id="item-4">
        <h1>Generating Trace and Stream objects from data</h1>
        <p>
            In addition to reading seismological file formats, you have the flexibility to create your own <code>Trace</code> and <code>Stream</code> objects using ObsPy's 
            <code>obspy.core.trace.Trace</code> and <code>obspy.core.stream.Stream</code> classes. To create a <code>Trace</code> object, begin by 
            supplying the data values of the recording (e.g., acceleration) as a NumPy <code>ndarray</code> to the <code>data</code> parameter within 
            <code>obspy.core.trace.Trace</code>, and include the recording's metadata in a Python dictionary provided to the <code>header</code> parameter. 
            Do this for each trace you want to create. Then, gather all the generated <code>Trace</code> objects into a Python list and pass it into the  
            <code>traces</code> parameter in the <code>obspy.core.stream.Stream</code> class to construct a <code>Stream</code> object.
        </p>
        <p>
            Below is presented  a seismic recording from the <i>LEF2</i> station, containing data from three channels (E, N, Z). This data file includes metadata 
            information positioned at the file's header, followed by data for each component. Our goal is to read this file and assemble a <code>Stream</code> 
            object comprising three individual traces.
        </p>
        <div class="figure-container">
            <figure>
                <img src="/static/img/record-txt-file.png" alt="mseed record ASCII file">
                <figcaption>Acceleration data in raw ASCII format. The first lines contain the record metadata and the rest of the lines the acceleration data of the three components</figcaption>
            </figure>
        </div>
        <p>
            Start by reading the file and collecting the file header information in order to build a dictionary of the seismic parameters. Then extract the acceleration values 
            of the recording and transform them into a numpy <code>ndarray</code> form. Lastly, create one <code>Trace</code> for each recording and then a 
            <code>Stream</code> object from the traces.
        </p>
        <script src="https://gist.github.com/imarag/aa31087909ed1dd16eafd7dcf73a8961.js"></script>
        <p>
            Before we add the metadata into the dictionary, we convert the number of points (npts) into a Python <code>int</code> datatype, the
            sampling frequency (fs) into a <code>float</code> datatype and the start time of the record (<code>starttime</code>) into a <code>UTCDateTime</code> object.
            Also it is important for the keys of the dictionary, to be one of the options provided in the 
            <a target="_blank" href="https://docs.obspy.org/packages/autogen/obspy.core.trace.Stats.html"><code>obspy.core.trace.Stats</code> </a> object. 
            Then we use the python Pandas library to read the data of the record. At this time we have the metadata and the data of the traces. Using these two parameters, we can create the <code>Trace</code> objects. To do this, loop trough the components, create a header dictionary file for each <code>Trace</code> and add its data:
        </p>
        <script src="https://gist.github.com/imarag/165bea0905ccd37d5f1f9497b3a1460a.js"></script>
        <p>Finally, create the <code>Stream</code> object, from the list of the traces:</p>
        <script src="https://gist.github.com/imarag/ee7d33d5071c7199fc13a19c0452fd25.js"></script>
        <p>Finally, use the <code>stream</code> <code>write()</code> method to save the stream somewhere in your machine.</p>
    </div>
            
{% endblock %}


