{% extends 'base.html' %}

{% block title %}
    Python obspy
{% endblock %}


{% block content %}
    <section class="bg-light">
        <div class="py-3 container-lg">
            <div class="row justify-content-center align-items-center  pt-5 mb-4 ">
                <div class="col-lg-2 col-3 col-md-2 d-none d-md-block">
                    <a href="https://docs.obspy.org/">
                        <img src="/static/img/templates-icons/file-manipulation.png" alt="mseed record ASCII file" class="img-fluid">
                    </a>
                </div>
                <div class="col-lg-9 col-10 col-md-8 text-center text-md-start">
                    <p class="display-1">Python File Manipulation</p>
                </div>
                    
            </div>

            <div class="fs-2 lead fst-italic text-muted">
                <p class="text-center text-md-start">Python provides a wide variety of tools and functions for handling various file-related tasks, such as file opening, reading, writing, handling file paths, pattern searching, file and folder listing and more </p>
            </div>


            
            
            <div class="text-center fs-5 my-5" id="hyper-reference-pills-container">
                <a target="_blank" href="https://docs.python.org/3/library/os.html"><span class="badge rounded-pill">os</span></a>
                <a target="_blank" href="https://docs.python.org/3/library/os.path.html"><span class="badge rounded-pill">os.path</span></a>
                <a target="_blank" href="https://docs.python.org/3/library/pathlib.html"><span class="badge rounded-pill">pathlib</span></a>
                <a target="_blank" href="https://docs.python.org/3/library/shutil.html"><span class="badge rounded-pill">shutil</span></a>
                <a target="_blank" href="https://docs.python.org/3/library/glob.html"><span class="badge rounded-pill">glob</span></a>
                <a target="_blank" href="https://docs.python.org/3/library/re.html"><span class="badge rounded-pill">re</span></a>
            </div>
        </div>
    </section>

    <div class="lead fs-3 container-lg">
      <section>
          <h1 class="text-center display-4 text-info my-5">Introduction</h1>
          <p>
            Python is a multi-tasking programming language. There are many tasks that someone can accomplish by using it. 
            From all the different libraries, tools and functions available, guess what, Python is also great at manipulating files.
            It provides mutliple libraries for file path handling, regular expression matching, creating, removing, renaming folders and files,
            directory searching, listing of the contents of folders and files, checking existence of files and more. Some of the most popular
            libraries used for this purpose are the <b>os</b> library that provides a way to use various operating system functionality,
            the <b>pathlib</b> library that offers an approach to working with system paths and file manipulation, the <b>shutil</b> library
            which is built on top of the <b>os</b> library and provides a high level file operations, then the <b>glob</b> library which is
            used for pattern matching and lastly the <b>re</b> library for regular expression support.
          </p>
      </section>

      <section>
        <h1 class="text-center display-4 text-info my-5">Path Handling</h1>
        <p>
          Python offers the <b><code>os.path</code></b> module and the 
          <b><code>pathlib</code></b> library for file and directory path handling. Let's 
          initialize them first:
        </p>
        <div class="input-code-block">
          <pre><code><span class="python-color1">import</span> os
            <span class="python-color1">import</span> pathlib</code></pre>
        </div>
        <p>
          The <code>os.path</code> module offers great functionality to handle file paths 
          such as:
        </p>
        <ul>
          <li><code>os.getcwd()</code>, that gets the current working directory path as a Python string</li>
          <li><code>os.path.basename(path)</code>, that extracts the last component of the provided path which is a file or a directory name</li>
          <li><code>os.path.dirname(path)</code>, that essentially extracts everything from the beginning of the path up to, but not including, the last path component</li>
          <li><code>os.path.split(path)</code>, it takes the path as input and returns a tuple with the <code>os.path.dirname</code> as the first element and the <code>os.path.basename</code> as the second element</li>
          <li><code>os.path.splitext(path)</code>, it is used to split a file path into two parts: the root part of the path (everything before the last dot) and the file extension (including the dot)</li>
          <li><code>os.path.join(path, *path)</code>, it is used to join one or more path components together to create a valid file path. The return value is a concatenation of all the provided components</li>
          <li><code>os.path.exists(path)</code>, it is used to check whether a file or directory exists at a given path</li>
          <li><code>os.path.isdir(path)</code>, it is used to check whether a given path corresponds to a directory (<code>True</code>) or not (<code>False</code>)</li>
          <li><code>os.path.isfile(path)</code>, it is used to check whether a given path corresponds to a file (<code>True</code>) or not (<code>False</code>)</li>
        </ul>
        <p>
          Let's see about all these functions at an example to better understand them. Suppose that we have the following file path that we need to manipulate:
        </p>
        <div class="input-code-block">
          <pre><code>mypath = "c:/Users/User/Desktop/myfile.txt"
            </code></pre>
        </div>
        <p>
        <p>Let's see how can we can get the basename and the dirname of the path:</p>
        <div class="input-code-block">
          <pre><code><span class="comment"># get the basename and the dirname of the path</span>
            bs_name = <span class="python-color1">os.path.basename(</span>mypath<span class="python-color1">)</span>
            <span class="python-color1">print(</span>bs_name<span class="python-color1">)</span>
            <span class="python-color1">print()</span>
            dir_name = <span class="python-color1">os.path.dirname(</span>mypath<span class="python-color1">)</span>
            <span class="python-color1">print(</span>dir_name<span class="python-color1">)</span>
            </code></pre>
        </div>
        <div class="output-code-block">
          <pre><code>myfile.txt

            c:/Users/User/Desktop
              </code></pre>
        </div>
        <p>We can also do the same using the <code>os.path.split</code> command:</p>
        <div class="input-code-block">
          <pre><code><span class="comment"># get the basename and the dirname of the path</span>
            <span class="comment"># return a tuple: (basename, dirname)</span>
            dir_name, bs_name = <span class="python-color1">os.path.split(</span>mypath<span class="python-color1">)</span>
            <span class="python-color1">print(</span>bs_name, dir_name<span class="python-color1">)</span>
            </code></pre>
        </div>
        <div class="output-code-block">
          <pre><code>myfile.txt c:/Users/User/Desktop
              </code></pre>
        </div>
        <p>Suppose that we need to get the file extension (without the dot) and also the path of the file without its extension:</p>
        <div class="input-code-block">
          <pre><code><span class="comment"># get the path of the file (everything before the last dot)</span>
            <span class="comment"># and the file extension</span>
            file_path, file_ext = <span class="python-color1">os.path.splitext(</span>mypath<span class="python-color1">)</span>
            <span class="comment"># the file_ext returns the extension with the dot (e.g, .txt)</span>
            <span class="comment"># so remove the dot</span>
            file_ext = file_ext<span class="python-color1">[</span>1:<span class="python-color1">]</span>
            <span class="python-color1">print(</span>file_path, file_ext<span class="python-color1">)</span>
            </code></pre>
        </div>
        <div class="output-code-block">
          <pre><code>c:/Users/User/Desktop/myfile txt
              </code></pre>
        </div>
        <p>How can we get the name (just the name, not the path) of the parent folder of the file?</p>
        <div class="input-code-block">
          <pre><code><span class="comment"># get the name of the folder that the file is located inside</span>
            parent_name = <span class="python-color1">os.path.basename(os.path.dirname(</span>mypath<span class="python-color1">))</span>
            <span class="python-color1">print(</span>parent_name<span class="python-color1">)</span>
            </code></pre>
        </div>
        <div class="output-code-block">
          <pre><code>Desktop
              </code></pre>
        </div>
        <p>How do we know if the path is indeed located somewhere in the computer ? In our case it doesn't but let's try it:</p>
        <div class="input-code-block">
          <pre><code><span class="comment"># check if the path exists somewhere</span>
            <span class="python-color1">print(os.path.exists(</span>mypath<span class="python-color1">))</span>
            </code></pre>
        </div>
        <div class="output-code-block">
          <pre><code>False
              </code></pre>
        </div>
        <p>Check to see if the path is pointing to a file or a directory (in our case the file or the path does not exist, so both commands (<code>os.path.isdir</code>, <code>os.path.isfile</code>) will return <code>False</code>:</p>
        <div class="input-code-block">
          <pre><code><span class="comment"># check if the path provided, is a file or a directory</span>
            <span class="python-color1">print(</span>'is a file: ', <span class="python-color1">os.path.isfile(</span>mypath<span class="python-color1">))</span>
            <span class="python-color1">print(</span>'is a directory: ', <span class="python-color1">os.path.isdir(</span>mypath<span class="python-color1">))</span>
            </code></pre>
        </div>
        <div class="output-code-block">
          <pre><code>is a file:  False
            is a directory:  False
              </code></pre>
        </div>
        <p>Suppose that we changed the location of the file and we put it in a folder called <i>data_files</i> located in the current working directory. How can we access its path using the old "mypath" path ?</p>
        <div class="input-code-block">
          <pre><code><span class="comment"># get the path of the file inside the new location</span>
            new_file_path = <span class="python-color1">os.path.join(os.path.dirname(</span>mypath<span class="python-color1">)</span>, 'data_files', 'myfile.txt'<span class="python-color1">)</span>
            <span class="python-color1">print(</span>new_file_path<span class="python-color1">)</span>
            </code></pre>
        </div>
        <div class="output-code-block">
          <pre><code>c:/Users/User/Desktop\data_files\myfile.txt
              </code></pre>
        </div>
        <p>Or you can just copy the path of the new folder from the Windows "option menu" directly. But why to choose the easy solution :p</p>
        <p>
          As you can see the Python <code>os</code> library is great at handling the file paths. However, it gets really annoying sometimes when we have to 
          write multiple functions one after another to simply get the name of a part of the path (e.g., <code>os.path.basename(os.path.dirname(path))</code>).
          You could import the <code>basename</code> and the <code>dirname</code> from the <code>os.path</code> module but there is a better 
          solution to this: the Python <code>pathlib</code> library. It is built on top of the <code>os</code> library and provides an easier way to accomplish
          all of the previous tasks:
        </p>
        <p>
          Let's get again the initial file path:
        </p>
        <div class="input-code-block">
          <pre><code>mypath = "c:/Users/User/Desktop/myfile.txt"
            </code></pre>
        </div>
        <p>Start by importing the main <code>Path</code> class and wrap the "mypath" variable with the imported Path class:</p>
        <div class="input-code-block">
          <pre><span class="python-color1">from</span> pathlib <span class="python-color1">import</span> Path
            mypath = <span class="python-color1">Path(</span>mypath<span class="python-color1">)</span>
            </code></pre>
        </div>
        <p>This will give you a <code>pathlib.WindowsPath</code> (if you are on Windows) and a <code>pathlib.PosixPath</code> if you are on Linux. Now you have full access to all of its functionality that will make your life easier. It contains many attributes that can get different parts of the path by just using the "dot" syntax as you it is presented at the image below:</p>
        <div class="input-code-block">
          <pre><code><span class="comment"># get the different parts of the path</span>
            <span class="python-color1">print(</span>"mypath.name: ", mypath.name<span class="python-color1">)</span>
            <span class="python-color1">print(</span>"mypath.stem: ", mypath.stem<span class="python-color1">)</span>
            <span class="comment"># use .suffixes if you have many file endings</span>
            <span class="python-color1">print(</span>"mypath.suffix: ", mypath.suffix<span class="python-color1">)</span>
            <span class="python-color1">print(</span>"mypath.parent: ", mypath.parent<span class="python-color1">)</span>
            </code></pre>
        </div>
        <div class="output-code-block">
          <pre><code>mypath.name:  myfile.txt
            mypath.stem:  myfile
            mypath.suffix:  .txt
            mypath.parent:  c:\Users\User\Desktop
              </code></pre>
        </div>
        <div class="row text-center justify-content-center align-items-center">
          <div class="col-lg-8 col-md-10 col-12">
              <figure>
                  <img src="/static/img/file-manipulation/pathlib_path_structure.png" alt="mseed record ASCII file" class="img-fluid my-5">
                  <figcaption class="lead fs-5 fst-italic">Get the different parts of a path using the "dot" syntax of the <code>pathlib.Path</code> class</figcaption>
              </figure> 
          </div>
        </div>
        <p>You can also split the path and get each part seperately using the <code>.parts</code> attribute: </p>
        <div class="input-code-block">
          <pre><code><span class="comment"># get all of the path parts seperately</span>
            <span class="python-color1">print(</span>mypath.parts<span class="python-color1">)</span>
            </code></pre>
        </div>
        <div class="output-code-block">
          <pre><code>('c:\\', 'Users', 'User', 'Desktop', 'myfile.txt')
              </code></pre>
        </div>
        <p>In addition, using the <code>.parents</code> syntax you can get the location path of each of the parents in the provided path. It will return an array of pathlib <code>WindowsPath</code> elements: </p>
        <div class="input-code-block">
          <pre><code><span class="comment"># get the path of each of the parents</span>
            <span class="python-color1">print(list(</span>mypath.parents<span class="python-color1">))</span>
            </code></pre>
        </div>
        <div class="output-code-block">
          <pre><code>[WindowsPath('c:/Users/User/Desktop'), WindowsPath('c:/Users/User'), WindowsPath('c:/Users'), WindowsPath('c:/')]
              </code></pre>
        </div>
        <p>Another great functionality of a <code>pathlib.Path</code> object is that you can create new paths with modified parts (e.g., new suffix or new name) by just using a "dot syntax":</p>
        <div class="input-code-block">
          <pre><code><span class="comment"># initial path</span>
            mypath = "c:/Users/User/Desktop/myfile.txt"
            <span class="comment"># pathlib WindowsPath</span>
            mypath = <span class="python-color1">Path(</span>"c:/Users/User/Desktop/myfile.txt"<span class="python-color1">)</span>
            <span class="comment"># new path with file ending ".png"</span>
            <span class="python-color1">print(</span>mypath.<span class="python-color1">with_suffix(</span>".png"<span class="comment">))</span>
            <span class="comment"># new path with different stem "another_file"</span>
            <span class="python-color1">print(</span>mypath.<span class="python-color1">with_suffix(</span>".png"<span class="comment">))</span>
            <span class="comment"># new path with different name "another_file.csv"</span>
            <span class="python-color1">print(</span>mypath.<span class="python-color1">with_suffix(</span>".png"<span class="comment">))</span>
            </code></pre>
        </div>
        <div class="output-code-block">
          <pre><code>c:\Users\User\Desktop\myfile.png
            c:\Users\User\Desktop\another_file.txt
            c:\Users\User\Desktop\another_file.csv
              </code></pre>
        </div>
        <p>
          One of the most useful pathlib features is the concatenation of different path 
          parts together. Remember that in the Python <code>os</code> library we used the 
          <code>join</code> function to concatenate different path segments together. Pathlib
          also has a similar function called <code>joinpath</code>. However, you can achieve the
          same functionality of <code>joinpath</code> by just using a forward slash between a 
          pathlib path (WindowsPath, PosixPath) and a string. You need to have at least one pathlib
          path for this to work. The following will have the same output:
        </p>
        <div class="input-code-block">
          <pre><code><span class="comment"># join path segments using a forward slash ('/')</span>
            mypath = "c:/Users/User/Desktop/myfile.txt"
            <span class="python-color1">print(</span>'c:/Users', <span class="python-color1">Path(</span>'user'<span class="python-color1">)</span>, 'Desktop', 'myfile.txt'<span class="python-color1">)</span>
            <span class="python-color1">print(</span>'c:/Users', <span class="python-color1">Path(</span>'user'<span class="python-color1">)</span>, 'Desktop', <span class="python-color1">Path(</span>'myfile.txt'<span class="python-color1">))</span>
            <span class="python-color1">print(Path(</span>'c:/Users'<span class="python-color1">)</span>, 'user', 'Desktop', 'myfile.txt'<span class="python-color1">)</span>
            <span class="python-color1">print(Path(</span>'c:/Users'<span class="python-color1">)</span>, <span class="python-color1">Path(</span>'user'<span class="python-color1">)</span>, <span class="python-color1">Path(</span>'Desktop'<span class="python-color1">)</span>, <span class="python-color1">Path(</span>'myfile.txt'<span class="python-color1">))</span>
            <span class="python-color1">print(</span>'c:/Users', 'user', 'Desktop', <span class="python-color1">Path(</span>'myfile.txt'<span class="python-color1">))</span>
            </code></pre>
        </div>
        <div class="output-code-block">
          <pre><code>c:/Users user Desktop myfile.txt
            c:/Users user Desktop myfile.txt
            c:\Users user Desktop myfile.txt
            c:\Users user Desktop myfile.txt
            c:/Users user Desktop myfile.txt
              </code></pre>
        </div>
        <p>
          Other functionality similar to the <code>os</code> library includes the 
          <code>WindowsPath.exists()</code> to check if a file or directory exists, the  
          <code>pathlib.Path.cwd()</code> and <code>pathlib.Path.home()</code> to get the 
          current working directory and the user's home directory,  the  
          <code>WindowsPath.is_dir()</code> and <code>WindowsPath.is_file()</code> to check 
          whether a path points to a file or a directory and lastly the 
          <code>WindowsPath.as_posix()</code> to convert the windows backslashes ("\") to 
          forward slashes ("/").</p>
          <div class="shadow-lg bg-light-red1 w-100 mx-auto my-5 rounded border border-1 border-secondary">
            <p class="ps-2 bg-info">
              
              <img style="width:30px; height:30px; vertical-align: middle;" class="img-fluid" src="{{ url_for('static', filename='img/file-manipulation/information-icon.png') }}" alt="information circle symbol">
              <span class="fs-4 fw-semibold">Note</span>
            </p>
            <p class="p-3 fs-4 text-dark">
              The <code>pathlib.Path</code> mentioned previously, is the import <code>Path</code>
              class. So when you want to get the current working directory use <code>Path.cwd()</code>. 
              Respectively, the <code>WindowsPath</code> is a pathlib path that results either from the
              <code>Path</code> class (e.g., <code>Path(mypath)</code>) or a path calculated from any of
              the available pathlib functions (e.g., <code>mypath.with_suffix(".txt")</code>).
            </p>
          </div>
      </section>

      <section>
          <h1 class="text-center display-4 text-info my-5">Managing Files and Folders</h1>
          <p>
            During the path handling we used the python <code>os</code> and <code>pathlib</code> to
            manipulate file and directory paths. However, these libraries in combination with other (e.g., <code>shutil</code>)
            can also be used effectively to create, move, copy and rename files and folders. Some of the 
            most important functions are listed below: 
          </p>
          <ul>
            <li><code>os.mkdir(path)</code>, create a directory named <i>path</i>. You can pass a single string value to create a directory with name <i>path</i> in the current working directory or provide a path to create a directory inside another folder. If the directory already exists or any of its parents is missing, it will give you an error. Use <code>os.makedirs</code> function to create the folder and all of the intermediate parents needed to complete the path</li>
            <li><code>os.makedirs(path)</code>, recursively create directories or folders along with any necessary parent directories. This function is particularly useful when you need to ensure that a directory structure exists for a given path</li>
            <li><code>os.rmdir(path)</code>, remove the provided directory path. If the path does not exist or is not empty, an error will be raised. In order to remove whole non-empty directory trees use the <code>shutil.rmtree()</code> function</li>
            <li><code>shutil.rmtree(path, ignore_errors=False)</code>, delete an entire empty or non-empty directory tree.  If <code>ignore_errors</code> is <code>True</code>, errors resulting from failed removals will be ignored</li>
            <li><code>shutil.move(path)</code>, recursively move a file or directory (src) to another location (dst)</li>
            <li><code>shutil.copyfile(src, dist)</code>, copy only the contents of a file to another file, without preserving any metadata. Use <code>shutil.copy(src, dst)</code> when you want to copy a file while preserving its contents and permissions but not its metadata and <code>shutil.copy2(src, dist)</code> when you want to copy a file while preserving both its contents and metadata, including timestamps</li>
            <li><code>shutil.copytree(src, dist)</code>, recursively copy an entire directory tree from the source directory (src) to the destination directory (dst)</li>
            <li>Alternative functions of <code>os</code> provided by <code>pathlib</code></li>
          </ul>
      </section>
    </div>

{% endblock %}
